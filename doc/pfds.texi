\input texinfo.tex
@c %**start of header
@setfilename pfds.info
@settitle Purely Functional Data Structures in Scheme
@c %**end of header

@c page
@c ------------------------------------------------------------
@c Macros.
@c ------------------------------------------------------------

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      Purely Functional Data Structures in Scheme

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    PFDS

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           pfds

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Ian Price

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{ianprice90@@googlemail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2011, 2012

@c ------------------------------------------------------------

@set ORIGINAL_GITHUB_URL        @url{http://github.com/ijp/@value{PACKAGE_NICKNAME}}
@set REPACKAGED_GITHUB_URL      @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}

@set REQUIRED_VICARE_VERSION    0.3d1

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a
set of purely functional data structures written in @rnrs{6} Scheme.

The package is distributed under the terms of a liberal license and can
be downloaded from:

@center @value{ORIGINAL_GITHUB_URL}

@noindent
a repackaging under the @gnu{} Autotools, with verified support for
Vicare Scheme and providing this documentation is at:

@center @value{REPACKAGED_GITHUB_URL}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}@*
Edited by Marco Maggi @email{marco.maggi-ipsu@@poste.it}

@quotation
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

@enumerate
@item
Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

@item
Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

@item
The name of the author may not be used to endorse or promote products
derived from this software without specific prior written permission.
@end enumerate

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* pfds: (pfds).                 @value{TITLE}.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* bbtrees::                     Bounded Balance trees.
* deques::                      Double queues.
* dlists::                      Difference Lists.

Appendices

* Package License::             Package license.
* References::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a
set of purely functional data structures written in @rnrs{6} Scheme.

The package requires at least Vicare Scheme
@value{REQUIRED_VICARE_VERSION}.

The package provides libraries for the following data structures:

@table @strong
@item bbtrees
@item deques
@item dlists
@item finger trees
@item heaps
@item priority search queues (psqs)
@item queues
@item sequences
@item sets
@end table

@c page
@node bbtrees
@chapter Bounded Balance trees


@cindex Library @library{pfds bbtrees}
@cindex @library{pfds bbtrees}, library


@menu
* bbtrees conventions::         Documentation and @api{} conventions.
* bbtrees core::                Constructors and predicates.
* bbtrees inspection::          Inspection functions.
* bbtrees setget::              Setters and getters.
* bbtrees traversing::          Traversing functions.
* bbtrees set::                 Set operations.
* bbtrees index::               Indexing operations.
@end menu

@c page
@node bbtrees conventions
@section Documentation and @api{} conventions


The following conventions for function arguments hold:

@table @var
@item bbtree
It is the instance of bbtree the function acts upon.  Bbtree arguments
are @strong{never} mutated.

@item key
The argument is an association key.  For all procedures which take a
@var{key} as an argument, the @var{key} must be comparable with the
ordering procedure of the bbtree.

@item item<
The argument @var{item<} must be the ordering procedure: a predicate
function accepting two arguments and returning a boolean, @true{} if the
first argument is strictly less than the second.  For numeric collected
items: @var{item<} can be @func{<}; for string collected items:
@var{item<} can be @func{string<?}.
@end table

@c page
@node bbtrees core
@section Constructors and predicates


The following bindings are exported by the library @library{pfds
bbtrees}.


@defun make-bbtree @var{item<}
Build and return a new, empty bbtree.  Bbtrees derived from the returned
one will use the procedure argument @var{item<} for ordering keys.
@end defun


@defun bbtree? @var{any}
Return @true{} if the argument is a bbtree, @false{} otherwise.
@end defun


@defun bbtree->alist @var{bbtree}
Return the key/value associations from @var{bbtree} as a list of pairs.
The list returned is in sorted order according to the ordering procedure
of @var{bbtree}.  A consequence of this is that one could write a sort
procedure for lists of pairs as:

@example
(define (alist-sort alist <)
  (bbtree->alist (alist->bbtree alist <)))
@end example
@end defun


@defun alist->bbtree @var{alist} @var{item<}
Return the bbtree containing each of the key/value pairs in @var{alist},
using the @var{item<} argument as the ordering procedure.

@example
(import (vicare)
  (pfds bbtrees))

(alist->bbtree '(("foo" . 10) ("bar" . 12))
               string<?)
@result{} #[bbtree]
@end example
@end defun

@c page
@node bbtrees inspection
@section Inspection functions


The following bindings are exported by the library @library{pfds
bbtrees}.


@defun bbtree-size @var{bbtree}
Return a non--negative integer representing number of elements in a
bbtree.
@end defun


@defun bbtree-contains? @var{bbtree} @var{key}
Return @true{} if there is association for @var{key} in @var{bbtree},
@false{} otherwise.
@end defun


@defun bbtree-ordering-procedure @var{bbtree}
Return the ordering procedure used internally to order @var{bbtree}.
@end defun


@defun bbtree-keys @var{bbtree}
Return a list containing all the keys of @var{bbtree}.  The keys are
sorted according to the bbtree's ordering procedure.

@example
(import (vicare)
  (pfds bbtrees))

(bbtree-keys (alist->bbtree '(("one" . 1) ("two" . 2))
                            string<?))
@result{} ("one" "two")
@end example
@end defun

@c page
@node bbtrees setget
@section Setters and getters


The following bindings are exported by the library @library{pfds
bbtrees}.


@defun bbtree-ref @var{bbtree} @var{key}
@defunx bbtree-ref @var{bbtree} @var{key} @var{default}
Return the value associated with the @var{key} in the @var{bbtree}.  If
the value is not in the tree, then, if the optional third argument is
passed, it is returned, otherwise an @condition{assertion-violation}
condition is raised.
@end defun


@defun bbtree-set @var{bbtree} @var{key} @var{new-value}
Return a new bbtree with @var{key} associated to @var{new-value}.  If
the @var{key} is already in @var{bbtree}, its associated value is
replaced with the new @var{new-value} in the returned bbtree.
@end defun


@defun bbtree-update @var{bbtree} @var{key} @var{proc} @var{default}
Return a new bbtree with the value associated to @var{key} updated
according to the update procedure @var{proc}.  If @var{key} was not
already in @var{bbtree}, the update procedure is applied to
@var{default}, and @var{key} is associated to the resulting value.

The update procedure @var{proc} must accept a single argument, being the
old value, and return a single value, being the new value.

@example
(import (vicare)
  (pfds bbtrees))

(let* ((bb1   (alist->bbtree '(("foo" . 10)
                               ("bar" . 12))
                             string<?))
       (dflt  0)
       (bb2   (bbtree-update bb1 "foo" add1 dflt)))
  (bbtree->alist bb2))
@result{} (("bar" . 12) ("foo" . 11))

(let* ((bb1  (alist->bbtree '(("foo" . 10)
                              ("bar" . 12))
                            string<?))
       (dflt 0)
       (bb2  (bbtree-update bb "baz" add1 dflt)))
  (bbtree->alist bb2))
@result{} (("bar" . 12) ("baz" . 1) ("foo" . 10))
@end example
@end defun


@defun bbtree-delete @var{bbtree} @var{key}
Return a new bbtree with the @var{key} and its associated value removed.
If @var{key} is not in @var{bbtree}: the returned bbtree is a copy of
the original.
@end defun

@c page
@node bbtrees traversing
@section Traversing functions


The following bindings are exported by the library @library{pfds
bbtrees}.


@defun bbtree-traverse @var{traverser} @var{accum-base} @var{bbtree}
A general tree traversal procedure.  Return the value of applying the
@var{traverser} procedure to: the current node's key, the current node's
value, a procedure to traverse the left subtree, a procedure to traverse
the right subtree, and an accumulator value.

The @var{traverser} procedure must look like:

@example
(define (traverser key value left-traverse right-traverse accum)
  ---)
@end example

@noindent
and return the new accumulator value.  The subtree traversal procedures
are generated by @func{bbtree-traverse}; both take the current
accumulator value as argument, return the new accumulator value, and
call @func{bbtree-traverse} recursively on the appropriate subtree.
@var{traverser} must call both @var{left-traverse} and
@var{right-traverse}:

@itemize
@item
If @var{left-traverse} is called first: the left subtree is visited
first.

@item
If @var{right-traverse} is called first: the right subtree is visited
first.
@end itemize

To perform a left--first preorder iteration:

@example
(import (rnrs)
  (pfds bbtrees))

(let ((bb (alist->bbtree (map (lambda (x) (cons x x))
                           '(0 1 2 3 4 5 6 7 8 9))
                         <)))
  (define (left-first key value left right accum)
    (right (left (cons key accum))))
  (bbtree-traverse left-first '() bb))
@result{} (9 8 6 7 4 5 2 0 1 3)
@end example

@noindent
and to perform a right--first preorder iteration:

@example
(import (rnrs)
  (pfds bbtrees))

(let ((bb (alist->bbtree (map (lambda (x) (cons x x))
                           '(0 1 2 3 4 5 6 7 8 9))
                         <)))
  (define (right-first key value left right accum)
    (left (right (cons key accum))))
  (bbtree-traverse right-first '() bb))
@result{} (0 2 1 4 6 9 8 7 5 3)
@end example

This function is mostly useful for implementing other, more specific
tree traversal procedures.  For example:

@example
(define (l-to-r-pre-order cons base bbtree)
  (bbtree-traverse (lambda (key value left right accum)
                     (right (left (cons* key value accum))))
                   accum
                   bbtree))
@end example

@noindent
implements a left--to--right pre--order traversal variant of
@func{bbtree-fold}.
@end defun


@defun bbtree-fold @var{combine} @var{accum-base} @var{bbtree}
Return the value obtained by iterating the @var{combine} procedure over
each node in the tree.  The combine procedure takes 3 arguments: the key
and value of the current node, and an accumulator value; its return
value is used as the accumulator value for the next node.  The initial
accumulator value is provided by the @var{accum-base} argument.

@func{bbtree-fold} performs a left--to--right in--order traversal or
``minimum key to maximum key''.

@example
(import (rnrs)
  (pfds bbtrees))

(let ((bb (alist->bbtree (map (lambda (x) (cons x x))
                           '(0 1 2 3 4 5 6 7 8 9))
                         <)))
  ;;Later keys are pushed on the head.
  (bbtree-fold (lambda (key value accum)
                 (cons key accum))
               '()
               bb))
@result{} (9 8 7 6 5 4 3 2 1 0)
@end example
@end defun


@defun bbtree-fold-right @var{combine} @var{accum-base} @var{bbtree}
Like @func{bbtree-fold}, but it performs a right--to--left in--order
traversal instead (i.e. maximum to minimum).

@example
(import (rnrs)
  (pfds bbtrees))

(let ((bb (alist->bbtree (map (lambda (x) (cons x x))
                           '(0 1 2 3 4 5 6 7 8 9))
                         <)))
  ;;Later keys are pushed on the head.
  (bbtree-fold-right (lambda (key value accum)
                       (cons key accum))
                     '()
                     bb))
@result{} (0 1 2 3 4 5 6 7 8 9)
@end example
@end defun


@defun bbtree-map @var{func} @var{bbtree}
Return a new bbtree obtained by updating the value of each node in
@var{bbtree} with the result of applying the procedure to its value.
@var{func} must take a single argument, being the original value, and
return a single value, being the new value.

@example
(import (rnrs)
  (pfds bbtrees))

(define bb
  (alist->bbtree '((#\a . foo)
                   (#\b . bar)
                   (#\c . baz)
                   (#\d . quux))
                 char<?))

(bbtree->alist (bbtree-map symbol->string bb))
@result{} ((#\a . "foo")
    (#\b . "bar")
    (#\c . "baz")
    (#\d . "quux"))
@end example
@end defun

@c page
@node bbtrees set
@section Set operations


The following bindings are exported by the library @library{pfds
bbtrees}.


@defun bbtree-union @vari{bbtree} @varii{bbtree}
Return a bbtree containing the union of the associations in
@vari{bbtree} and @varii{bbtree}.  Where the same key occurs in both:
the value in @vari{bbtree} is preferred.
@end defun


@defun bbtree-difference @vari{bbtree} @varii{bbtree}
Return a bbtree containing the all the associations in @vari{bbtree},
which do not occur in @varii{bbtree}.
@end defun


@defun bbtree-intersection @vari{bbtree} @varii{bbtree}
Return a bbtree containing all the associations which appear in both
@vari{bbtree} and @varii{bbtree}.  The values in @vari{bbtree} are
preferred over those in @varii{bbtree}.
@end defun

@c page
@node bbtrees index
@section Indexing operations


The following bindings are exported by the library @library{pfds
bbtrees}.


@defun bbtree-index @var{bbtree} @var{key}
Return a non--negative integer representing the index of @var{key} in
the @var{bbtree}.  The index is an integer between @code{0} and
@code{@var{size} - 1}, where @var{size} is the number of associations in
@var{bbtree}.
@end defun


@defun bbtree-ref/index @var{bbtree} @var{index}
Return 2 values: the key and value of the association in @var{bbtree} at
the given @var{index}.  @var{index} must be a non--negative integer
between @code{0} and @code{@var{size} - 1}, where @var{size} is the
number of associations in @var{bbtree}.
@end defun

@c page
@node deques
@chapter Double queues


The following bindings are exported by the library @library{pfds
deques}.


@defun make-deque
Return a deque containing to items.
@end defun


@defun deque? @var{obj}
Return @true{} if @var{obj} is a deque, @false{} otherwise.
@end defun


@defun deque-length @var{deque}
Return a non--negative integer representing the number of items in
@var{deque}.
@end defun


@defun deque-empty? @var{deque}
Return @true{} if there are no items in @var{deque}, @false{} otherwise.
@end defun


@defun enqueue-front @var{deque} @var{item}
Return a new deque with the @var{item} inserted at the front.
@end defun


@defun enqueue-rear @var{deque} @var{item}
Return a new deque with the @var{item} inserted at the rear.
@end defun


@defun dequeue-front @var{deque}
Return two values: the item at the front of @var{deque}, and a new deque
containing all the other items.  Raise a @condition{deque-empty}
condition if @var{deque} is empty.
@end defun


@defun dequeue-rear @var{deque}
Return two values: the item at the rear of the deque, and a new deque
containing all the other items.  Raise a @condition{deque-empty}
condition if @var{deque} is empty.
@end defun


@defun deque-empty-condition? @var{obj}
Return @true{} if @var{obj} is a @condition{deque-empty} condition,
@false{} otherwise.
@end defun


@defun deque->list @var{deque}
Return a list containing all the elements of @var{deque}.  The order of
the elements in the list is the same as the order they would be dequeued
from the front of the deque.
@end defun


@defun list->deque @var{list-of-items}
Return a deque containing all of the elements in the list argument.  The
order of the elements in the deque is the same as the order of the
elements in the list.
@end defun

@c page
@node dlists
@chapter Difference Lists


Repeatedly appending to a list is a common, if inefficient pattern in
functional programs.  Usually the trick we use is to build up the list
in reverse, and then to reverse it as the last action of a function.
Dlists are a representation of lists as functions that provide for
constant time append to either the front or end of a dlist that may be
used instead.

The following bindings are exported by the library @library{pfds
dlists}.


@defun dlist @var{obj} @dots{}
Return a dlist containing all the given arguments.
@end defun


@defun dlist? @var{obj}
Return @true{} if @var{obj} is a dlist, @false{} otherwise.
@end defun


@defun dlist-cons @var{item} @var{dlist}
Return a new dlist created by prepending @var{item} to the head of
@var{dlist}.
@end defun


@defun dlist-snoc @var{dlist} @var{item}
Return a new dlist created by appending @var{item} to the tail of
@var{dlist}.
@end defun


@defun dlist-append @vari{dlist} @varii{dlist}
Return a new dlist consisting of all the elements of @vari{dlist},
followed by all the items of @varii{dlist}.
@end defun


@defun dlist->list @var{dlist}
Return a list consisting of all the elements of the @var{dlist}.
@end defun


@defun list->dlist @var{list-of-items}
Return a dlist consisting of all the elements of the given list
argument.
@end defun

@c page
@node Package License
@chapter Package license


@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

@enumerate
@item
Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

@item
Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

@item
The name of the author may not be used to endorse or promote products
derived from this software without specific prior written permission.
@end enumerate

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

@c page
@node References
@appendix Bibliography and references


The queues and deques are based on the paper:

@quotation
Chris Okasaki.  ``Simple and Efficient Purely Functional Queues and
Deques''.  @url{http:/@//@/www.eecs.usma.edu/@/webs/@/people/@/okasaki/@/pubs.html#jfp95}.
@end quotation

The bbtrees and sets are based on the paper:

@quotation
Stephen Adams.  ``Implementing Sets Efficiently in a Functional
Language''.  @url{http:/@//@/groups.csail.mit.edu/@/mac/@/users/@/adams/@/BB/@/92-10.ps}.
@end quotation

Dlists are a well known trick in the functional programming community,
going back to at least:

@quotation
John Hughes.  ``A Novel Representation of Lists and its application to
the Function @emph{Reverse}''.  1984.
@url{http:/@//@/www.cs.tufts.edu/@/~nr/@/cs257/@/archive/@/john-hughes/@/lists.pdf}
@end quotation

@noindent
although he does not give them this name.  The trick is likely even
older than that (he points to a paper by Bird), though I have not the
knowledge to confirm this.

The implementation of priority search queues is described in:

@quotation
Ralf Hinze.  ``A Simple Implementation Technique for Priority Search
Queues''.
@url{http:/@//@/www.cs.ox.ac.uk/@/people/@/ralf.hinze/@/publications/@/UU-CS-2001-09.pdf}.
@end quotation

The heaps use a height--biased leftist tree implementation.  Finger
trees are described in.

@quotation
Ross Paterson and Ralf Hinze.  ``Finger trees: a simple general-purpose
data structure''.
@url{http:/@//@/www.soi.city.ac.uk/@/~ross/@/papers/@/FingerTree.html}.
@end quotation

@c ------------------------------------------------------------

@subsubheading Thanks

Thanks to Llewellyn Pritchard (@url{https:/@//@/github.com/@/leppie})
for testing this on IronScheme
(@url{https:/@//@/ironscheme.codeplex.com/@/}), and to Andy Wingo
(@url{http:/@//@/wingolog.org/@/}) for pointing out priority search
queues to me, and prodding me into implementing them.

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

