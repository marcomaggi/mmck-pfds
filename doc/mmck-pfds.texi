\input texinfo.tex
@c %**start of header
@setfilename mmck-pfds.info
@settitle Purely Functional Data Structures in Scheme
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      Purely Functional Data Structures in Scheme

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    @sc{mmck} @sc{PFDS}

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmck-pfds

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2019

@set CHICKEN_VERSION            5.0.0

@c ------------------------------------------------------------

@set PackageStem                pfds

@set PackageAutoconfPrefix      MMCK_PFDS
@set PackagePkgconfigModule     mmck-pfds

@set GithubUrl                  @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl                @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl           @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@set OriginalGithubUrl          @url{http://github.com/ijp/pfds}


@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@macro mmck{}
@sc{mmck}
@end macro

@macro chicken{}
@sc{chicken}
@end macro

@macro pfds{}
@sc{PFDS}
@end macro

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a set of @chicken{} language
libraries implementing purely functional data structures.  @chicken{} is a Scheme--to--C compiler
supporting the language features as defined in the ``Revised^5 Report on Scheme''.

The library supports @posix{} platforms.  This package has been tested with @chicken{} version
@value{CHICKEN_VERSION}.

This package is distributed under the terms of a liberal license.

The latest release can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}@*
Copyright @copyright{} 2011, 2012 Ian Price @email{ianprice90@@googlemail.com}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} Lesser
General Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mmck-pfds: (mmck-pfds).   A pfds library for @chicken{}.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* dlists::                      Difference Lists.
* queues::                      Purely functional queues.
* deques::                      Double queues.
* psqs::                        Priority search queues.
* fingertrees::                 A simple general-purpose data structure.
* sequences::                   Purely functional sequences.
* heaps::                       Heaps.
* bbtrees::                     Bounded Balance trees.
* sets::                        Purely functional sets.
* exceptions::                  Exceptional-condition object-types.

Appendices

* Package License::             Package license.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


@cindex @library{mmck pfds}, library
@cindex Library @library{mmck pfds}


This document describes version @value{VERSION} of @value{PACKAGE}, a set of @chicken{} language
libraries implementing purely functional data structures.  @chicken{} is a Scheme--to--C compiler
supporting the language features as defined in the ``Revised^5 Report on Scheme''.

This package supports @posix{} platforms.  To run the tests distributed with the source code: this
package depends upon the package @mmck{} Checks.

The package installs the library @library{mmck pfds} along with its import libraries.  To require
the library and import its syntactic bindings in a module we can do:

@example
(declare (unit my-module)
         (emit-import-library my-module))

(require-library (mmck pfds))

(module (my-module)
    ()
  (import (scheme)
          (mmck pfds))

  ...

  #| end of module |# )
@end example

@c page
@node version
@chapter Version functions


@value{PACKAGE}'s version number follows the specification of @dfn{Semantic Versioning} version 2.0
as outlined at:

@center @url{https://semver.org/}

@noindent
the following functions are available to inspect the version specification at runtime.


@defun mmck-@value{PackageStem}-package-major-version
Return a fixnum representing the package's major version number.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the major version number is the fixnum @samp{1}.
@end defun


@defun mmck-@value{PackageStem}-package-minor-version
Return a fixnum representing the package's minor version number.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the minor version number is the fixnum @samp{2}.
@end defun


@defun mmck-@value{PackageStem}-package-patch-level
Return a fixnum representing the package's patch level number.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the patch level number is the fixnum @samp{3}.
@end defun


@defun mmck-@value{PackageStem}-package-prerelease-tag
Return a string representing the package's prerelease tag.  As example, if the full semantic version
is @samp{1.2.3-devel.0+x86-64}: the prerelease tag is the string @samp{"devel.0"}.  This string may
be empty.
@end defun


@defun mmck-@value{PackageStem}-package-build-metadata
Return a string representing the package's build metadata.  As example, if the full semantic version
is @samp{1.2.3-devel.0+x86-64}: the build metadata is the string @samp{"x86-64"}.  This string may
be empty.  We need to remember that this specification segment must contain only @ascii{}
alphanumerics and hyphen @samp{[0-9A-Za-z-]}; underscores are @strong{not} allowed.
@end defun


@defun mmck-@value{PackageStem}-package-version
Return a string representing the package's version.  As example, if the full semantic version is
@samp{1.2.3-devel.0+x86-64}: the package version is the string @samp{"1.2.3-devel.0"}, without the
build metadata.
@end defun


@defun mmck-@value{PackageStem}-package-semantic-version
Return a string representing the package's semantic version.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the package version is the string
@samp{"v1.2.3-devel.0+x86-64"}, notice the leading character @samp{v}.
@end defun

@c page
@node dlists
@chapter Difference Lists


Repeatedly appending to a list is a common, if inefficient pattern in functional programs.  Usually
the trick we use is to build up the list in reverse, and then to reverse it as the last action of a
function.  Dlists are a representation of lists as functions that provide for constant time append
to either the front or end of a dlist that may be used instead.


@defun dlist @var{OBJ} @dots{}
Return a @class{dlist} containing all the given arguments.

@lisp
(dlist 1 2 3)   @result{} #[dlist 1 2 3]
@end lisp
@end defun


@defun dlist? @var{OBJ}
Return @true{} if @var{OBJ} is a @class{dlist}, @false{} otherwise.
@end defun


@defun dlist-cons @var{item} @var{dell}
Return a new @class{dlist} created by prepending @var{item} to the head of @var{dell}.

@lisp
(let* ((dell (dlist 5))
       (dell (dlist-cons 4 dell))
       (dell (dlist-snoc dell 6)))
  dell)
@result{} #[dlist 4 5 6]
@end lisp
@end defun


@defun dlist-snoc @var{dell} @var{item}
Return a new @class{dlist} created by appending @var{item} to the tail of @var{dell}.
@end defun


@defun dlist-append @var{dell} @dots{}
Return a new @class{dlist} consisting of the concatenation of the elements of the @var{dell}
arguments.  If no arguments are given: return the empty @class{dlist}.

@lisp
(dlist-append (dlist 1 2)
              (dlist 3 4)
              (dlist 5 6)
              (dlist 7 8))
@result{} #[dlist 1 2 3 4 5 6 7 8]
@end lisp
@end defun


@defun dlist->list @var{dell}
Return a list consisting of all the elements of the @var{dell}.
@end defun


@defun list->dlist @var{list-of-items}
Return a @class{dlist} consisting of all the elements of the given list argument.
@end defun


@defun dlist=? @var{dell} @dots{}
Return @true{} if all the @var{dell} arguments are equal; otherwise return @false{}.  If no
arguments are given: return @true{}.
@end defun

@c page
@node queues
@chapter Purely functional queues


This module implements a First--In First--Out functional queue:

@lisp
(let* ((Q (make-queue))
       (Q (enqueue Q 1))
       (Q (enqueue Q 2))
       (Q (enqueue Q 3)))
  (receive (A Q)
      (dequeue Q)
    (receive (B Q)
        (dequeue Q)
      (receive (C Q)
          (dequeue Q)
        (values A B C)))))
@result{} 1 2 3
@end lisp

@noindent
by applying repeatedly @func{dequeue} to the same @class{queue} object, we extract the same item
from the queue:

@lisp
(let* ((Q (make-queue))
       (Q (enqueue Q 1))
       (Q (enqueue Q 2))
       (Q (enqueue Q 3)))
  (receive (A Q1)
      (dequeue Q)
    (receive (B Q1)
        (dequeue Q)
      (receive (C Q1)
          (dequeue Q)
        (values A B C)))))
@result{} 1 1 1
@end lisp


@defun make-queue
Return a queue containing no items.
@end defun


@defun queue? @var{OBJ}
Return @true{} if @var{OBJ} is a queue, @false{} otherwise.
@end defun


@defun queue-length @var{queue}
Return a non--negative integer representing the number of items in @var{queue}.
@end defun


@defun queue-empty? @var{queue}
Return @true{} if there are no items in @var{queue}, @false{} otherwise.
@end defun


@defun enqueue @var{queue} @var{item}
Return a new queue with the enqueued @var{item} at the end.
@end defun


@defun dequeue @var{queue}
Return 2 values: the item at the front of @var{queue}, and a new queue containing the all the other
items.  Raise a condition with kind @code{pfds-queue-empty-condition} condition if @var{queue} is
empty.
@end defun


@defun queue-empty-condition? @var{OBJ}
Return @true{} if @var{OBJ} is a condition object with kind @code{pfds-queue-empty-condition};
otherwise return @false{}.
@end defun


@defun queue->list @var{queue}
Return a list containing all the items in @var{queue}.  The order of the item in the list is the
same as the order of the elements in the queue.
@end defun


@defun list->queue @var{list-of-items}
Return a queue containing all the items in the given list.  The order of the items in the queue is
the same as the order in the list.
@end defun

@c page
@node deques
@chapter Double queues


This module implements a functional deque:

@lisp
(let* ((Q (make-deque))
       (Q (enqueue-front Q 1))
       (Q (enqueue-front Q 2))
       (Q (enqueue-front Q 3)))
  (receive (A Q)
      (dequeue-front Q)
    (receive (B Q)
        (dequeue-front Q)
      (receive (C Q)
          (dequeue-front Q)
        (values A B C)))))
@result{} 3 2 1

(let* ((Q (make-deque))
       (Q (enqueue-front Q 1))
       (Q (enqueue-front Q 2))
       (Q (enqueue-front Q 3)))
  (receive (A Q)
      (dequeue-rear Q)
    (receive (B Q)
        (dequeue-rear Q)
      (receive (C Q)
          (dequeue-rear Q)
        (values A B C)))))
@result{} 1 2 3
@end lisp

@noindent
by applying repeatedly the dequeue functions to the same @class{deque} object, we extract the same
item:

@lisp
(let* ((Q (make-deque))
       (Q (enqueue-front Q 1))
       (Q (enqueue-front Q 2))
       (Q (enqueue-front Q 3)))
  (receive (A Q1)
      (dequeue-front Q)
    (receive (B Q1)
        (dequeue-front Q)
      (receive (C Q1)
          (dequeue-front Q)
        (values A B C)))))
@result{} 3 3 3
@end lisp


@defun make-deque
Return a deque containing to items.
@end defun


@defun deque? @var{OBJ}
Return @true{} if @var{OBJ} is a deque, @false{} otherwise.
@end defun


@defun deque-length @var{deque}
Return a non--negative integer representing the number of items in @var{deque}.
@end defun


@defun deque-empty? @var{deque}
Return @true{} if there are no items in @var{deque}, @false{} otherwise.
@end defun


@defun enqueue-front @var{deque} @var{item}
Return a new deque with the @var{item} inserted at the front.
@end defun


@defun enqueue-rear @var{deque} @var{item}
Return a new deque with the @var{item} inserted at the rear.
@end defun


@defun dequeue-front @var{deque}
Return two values: the item at the front of @var{deque}, and a new deque containing all the other
items.  Raise a condition with kind @code{pfds-deque-empty-condition} if @var{deque} is empty.
@end defun


@defun dequeue-rear @var{deque}
Return two values: the item at the rear of the deque, and a new deque containing all the other
items.  Raise a condition with kind @code{pfds-deque-empty-condition} condition if @var{deque} is
empty.
@end defun


@defun deque-empty-condition? @var{OBJ}
Return @true{} if @var{OBJ} is a condition with kind @code{pfds-deque-empty-condition}, @false{}
otherwise.
@end defun


@defun deque->list @var{deque}
Return a list containing all the elements of @var{deque}.  The order of the elements in the list is
the same as the order they would be dequeued from the front of the deque.
@end defun


@defun list->deque @var{list-of-items}
Return a deque containing all of the elements in the list argument.  The order of the elements in
the deque is the same as the order of the elements in the list.
@end defun

@c page
@node psqs
@chapter Priority search queues


Priority search queues are a combination of two common abstract data types: finite maps, and
priority queues.  As such, it provides for access, insertion, removal and update on arbitrary keys,
as well as for easy removal of the element with the lowest priority.

Where a procedure takes a key or priority these are expected to be compatible with the relevant
ordering procedures on the @class{psq}.

@lisp
(let* ((Q (make-psq string< <))
       (Q (psq-set Q "salut" 2))
       (Q (psq-set Q "hello" 1))
       (Q (psq-set Q "ciao"  1))
       (Q (psq-set Q "ohayo" 2)))
  (receive (key1 Q1)
      (psq-pop Q)
    (receive (key2 Q2)
        (psq-pop Q1)
      (receive (key3 Q3)
          (psq-pop Q2)
        (receive (key4 Q4)
            (psq-pop Q3)
          (values key1 key2 key3 key4))))))
@result{} "ciao" "hello" "ohayo" "salut"
@end lisp

@menu
* psqs basic::                  Basic operations.
* psqs map::                    Finite map operations.
* psqs priority::               Priority queue operations.
* psqs ranged::                 Ranged query functions.
@end menu

@c page
@node psqs basic
@section Basic operations


@defun make-psq @var{KEY<} @var{PRIORITY<}
Take two ordering procedures: one for keys, and another for priorities, and return an empty priority
search queue.
@end defun


@defun psq? @var{OBJ}
Return @true{} if @var{OBJ} is a priority search queue, @false{} otherwise.
@end defun


@defun psq-empty? @var{PSQ}
Return @true{} if the priority search queue contains no elements, @false{} otherwise.
@end defun


@defun psq-size @var{PSQ}
Return a non--negative integer represeting the number of associations in the priority search queue.
@end defun

@c page
@node psqs map
@section Finite map operations


@defun psq-ref @var{PSQ} @var{KEY}
Return the priority of @var{KEY} if it is in @var{PSQ}.  If @var{KEY} is not in @var{PSQ} an
assertion violation is raised.

@lisp
(let* ((Q (make-psq string< <))
       (Q (psq-set Q "salut" 2))
       (Q (psq-set Q "hello" 1))
       (Q (psq-set Q "ciao"  4))
       (Q (psq-set Q "ohayo" 3)))
  (values (psq-ref Q "salut")
          (psq-ref Q "hello")
          (psq-ref Q "ciao")
          (psq-ref Q "ohayo")))
@result{} 2 1 4 3
@end lisp
@end defun


@defun psq-set @var{PSQ} @var{KEY} @var{PRIORITY}
Return the priority search queue obtained from inserting @var{KEY} with a given @var{PRIORITY}.  If
@var{KEY} is already in the priority search queue, it updates the priority to the new value.
@end defun


@defun psq-update @var{PSQ} @var{KEY} @var{PRIORITY-UPDATE} @var{DEFAULT-PRIORITY}
Return the priority search queue obtained by modifying the priority of @var{KEY}, by the given
function @var{PRIORITY-UPDATE}.  If @var{KEY} is not in @var{PSQ}: it is inserted with the priority
obtained by calling the function @var{PRIORITY-UPDATE} on the value @var{DEFAULT-PRIORITY}.

@var{PRIORITY-UPDATE} must be a procedure accepting a priority value as single argument and
returning a priority value as single value.

@lisp
(let* ((Q  (make-psq string< <))
       (Q  (psq-set Q "salut" 2))
       (P1 (psq-ref Q "salut"))
       (Q  (psq-update Q "salut"
                       (lambda (P) (+ 2 P))
                       0))
       (P2 (psq-ref Q "salut")))
  (values P1 P2))
@result{} 2 4

(let* ((Q  (make-psq string< <))
       (Q  (psq-update Q "salut"
                       (lambda (P) (+ 1 P))
                       9)))
  (psq-ref Q "salut"))
@result{} 10
@end lisp
@end defun


@defun psq-delete @var{PSQ} @var{KEY}
Return the priority search queue obtained by removing the @var{KEY}/priority association from the
@var{PSQ}.  If @var{KEY} is not in the queue: the returned search queue will be the same as the
original.
@end defun


@defun psq-contains? @var{PSQ} @var{KEY}
Return @true{} if there is an association for the given @var{KEY} in @var{PSQ}, @false{} otherwise.
@end defun

@c page
@node psqs priority
@section Priority queue operations


@defun psq-min @var{PSQ}
Return the key of the minimum association in @var{PSQ}.  If the queue is empty: an assertion
violation is raised.

@lisp
(let* ((Q (make-psq string< <))
       (Q (psq-set Q "salut" 2))
       (Q (psq-set Q "hello" 1))
       (Q (psq-set Q "ciao"  4))
       (Q (psq-set Q "ohayo" 3)))
  (psq-min Q))
@result{} "hello"
@end lisp
@end defun


@defun psq-delete-min @var{PSQ}
Return the priority search queue obtained by removing the minimum association in @var{PSQ}.  If the
queue is empty: an assertion violation is raised.
@end defun


@defun psq-pop @var{PSQ}
Return 2 values:

@enumerate
@item
The minimum key.

@item
The priority search queue obtained by removing the minimum association from @var{PSQ}.
@end enumerate

If the queue is empty: an assertion violation is raised.
@end defun

@c page
@node psqs ranged
@section Ranged query functions


@defun psq-at-most @var{PSQ} @var{PRIORITY}
Return an alist containing all the associations in @var{PSQ} with priority less than, or equal to,
the given @var{PRIORITY}.  The returned alist is ordered by key according to the predicate for
@var{PSQ}.

@lisp
(let* ((Q (make-psq key< priority<))
       (Q (psq-set Q "salut" 2))
       (Q (psq-set Q "hello" 1))
       (Q (psq-set Q "ciao"  4))
       (Q (psq-set Q "ohayo" 3)))
  (psq-at-most Q 2))
@result{} (("hello" . 1) ("salut" . 2))
@end lisp
@end defun


@defun psq-at-most-range @var{PSQ} @var{PRIORITY} @var{MIN-KEY} @var{MAX-KEY}
Similar to @func{psq-at-most}, but it also takes an upper and lower bound, for the keys it will
return.  These bounds are inclusive.

@lisp
(let* ((Q (make-psq key< priority<))
       (Q (psq-set Q "salut" 1))
       (Q (psq-set Q "hello" 2))
       (Q (psq-set Q "ciao"  2))
       (Q (psq-set Q "ohayo" 2)))
  (psq-at-most-range Q 2 "hello" "salut"))
@result{} (("hello" . 2) ("ohayo" . 2) ("salut" . 1))
@end lisp
@end defun

@c page
@node fingertrees
@chapter A simple general--purpose data structure


@menu
* fingertrees intro::           Introduction to fingertrees.
* fingertrees ctors::           Core constructors and predicates.
* fingertrees exceptions::      Excepional-conditions related to fingertrees.
@end menu

@c page
@node fingertrees intro
@section Introduction to fingertrees


Fingertrees are a generalised form of deque, that we can parameterise to compute a value, called the
``measure'' of a fingertree.  This measure will be updated incrementally as we add and remove
elements from the fingertree.  Among other things, this allows fingertrees to be used where you
otherwise might have written a custom data structure.

To compute the measure, fingertrees require pieces of information: a converter, a combiner, and an
identity.

@itemize
@item
The @dfn{converter} is a procedure of one argument, that maps values in the fingertree to other
values which are used for computing the measure.

@item
The @dfn{combiner} is a procedure of two arguments, and combines these into one value representing
them both.  A combiner must be associative i.e.

@example
(combine A (combine B C)) @equiv{} (combine (combine A B) C)
@end example

@noindent
for all values @code{A}, @code{B} and @code{C}.

@item
An @dfn{identity} is a value that represents the measure of an empty fingertree.  It must obey the
rule that @code{(combine X identity)}, @code{(combine identity X)} and @code{X} are always the same.
@end itemize

To make things more concrete, a simple use of a fingertree is as a deque that keeps a running total.
In this case, the converter can simply be the function @code{(lambda (x) x)} if it is a deque of
integers, the combiner would be @func{+}, and the identity @code{0}.

@example
(define l '(3 1 4 1 5 9))

(define ft (list->fingertree l 0 + (lambda (x) x)))

(fingertree-measure ft)
@result{} 23

(fingertree-measure (fingertree-snoc ft 2))
@result{} 25

(let-values (((head tail) (fingertree-uncons ft)))
  (fingertree-measure tail))
@result{} 20
@end example

Mathematically speaking, the @strong{return type} of the converter, the combiner and the identity
element are expected to form a monoid.

@c page
@node fingertrees ctors
@section Core constructors and predicates


@defun make-fingertree @var{IDENTITY} @var{COMBINE} @var{measure}
Return a new fingertree, parameterised by the given monoid.
@end defun


@defun fingertree-measure @var{FINGERTREE}
Return the measure of @var{FINGERTREE}, as defined by @var{FINGERTREE}'s monoid.
@end defun


@defun fingertree? @var{OBJ}
Return @true{} if @var{OBJ} is a fingertree, @false{} otherwise.
@end defun


@defun fingertree-empty? @var{FINGERTREE}
Return @true{} if there are no items in the fingertree, @false{} otherwise.
@end defun


@defun fingertree-cons @var{item} @var{FINGERTREE}
Return the new fingertree created by adding the @var{item} to the front of @var{FINGERTREE}.
@end defun


@defun fingertree-snoc @var{FINGERTREE} @var{item}
Return the new fingertree created by adding @var{item} to the end of @var{FINGERTREE}.
@end defun


@defun fingertree-uncons @var{FINGERTREE}
Returns 2 values: the item at the front of @var{FINGERTREE}, and a new fingertree containing all but
the front element.  If @var{FINGERTREE} is empty: a @code{pfds-fingertree-empty-condition} condition
is raised.
@end defun


@defun fingertree-unsnoc @var{FINGERTREE}
Return 2 values: a new fingertree containing all but the rear element of @var{FINGERTREE}, and the
rear element itself.  If @var{FINGERTREE} is empty: a @code{pfds-fingertree-empty-condition}
condition is raised.
@end defun


@defun fingertree-append @vari{fingertree} @varii{fingertree}
Return a new fingertree which contains all of the elements of @vari{fingertree}, followed by all the
elements of @varii{fingertree}.  The arguments are assumed to be parameterised by the same monoid.
@end defun


@defun list->fingertree @var{list-of-items} @var{identity} @var{append} @var{convert}
Return a fingertree containing all of the elements of the list argument, in the same order.
@end defun


@defun fingertree->list @var{FINGERTREE}
Return a list of all the items in @var{FINGERTREE}, in the order they would be unconsed.
@end defun


@defun fingertree-split @var{predicate} @var{FINGERTREE}
Return 2 values: a new finger tree representing the largest prefix of @var{FINGERTREE} for which
applying the @var{predicate} to it's accumulated measure returns @false{}; is a new fingertree
containing all those elements not in the first fingertree.

@var{predicate} must be a function accepting a single argument and returning a boolean.
@end defun


@defun fingertree-split3 @var{predicate} @var{FINGERTREE}
Similar to @func{fingertree-split}, however, instead of returning the remainder as the second
argument, return the head of the remainder as second value, and tail of the remainder as third
value.
@end defun


@defun fingertree-fold @var{COMBINER} @var{ACCUM-BASE} @var{FINGERTREE}
Return the value obtained by iterating the @var{COMBINER} procedure over @var{FINGERTREE} in
left--to--right order.  This procedure takes two arguments: the current value from @var{FINGERTREE},
and an accumulator; it's return value is used as accumulator for the next iteration.  The initial
value for the accumulator is given by the base argument.
@end defun


@defun fingertree-fold-right @var{COMBINER} @var{FINGERTREE}
Similar to @func{fingertree-fold}, but iterate in right--to--left order.
@end defun


@defun fingertree-reverse @var{FINGERTREE}
Return a new fingertree in which the items are in the opposite order from @var{FINGERTREE}.
@end defun

@c page
@node fingertrees exceptions
@section Excepional-conditions related to fingertrees


@defun fingertree-empty-condition? @var{condition}
Return @true{} if the argument is a @code{pfds-fingertree-empty-condition} condition, @false{}
otherwise.
@end defun

@c page
@node sequences
@chapter Purely functional sequences


Sequences are a general--purpose, variable--length collections, similar to lists, however they
support efficient addition and removal from both ends, and random--access.  Like other Scheme
collections, sequences are zero--indexed.


@defun make-sequence
Return a new empty sequence.
@end defun


@defun sequence @var{item} @dots{}
Return a new sequence containing all of the argument items, in the given order.
@end defun


@defun sequence? @var{OBJ}
Return @true{} if the argument is a sequence, @false{} otherwise.
@end defun


@defun sequence-empty? @var{sequence}
Return @true{} if @var{sequence} contains no items, @false{} otherwise.
@end defun


@defun sequence-size @var{sequence}
Return a non--negative integer representing the number of items in @var{sequence}.
@end defun


@defun sequence-cons @var{item} @var{sequence}
Return a new sequence created by adding @var{item} to the front of @var{sequence}.
@end defun


@defun sequence-uncons @var{sequence}
Return 2 values: the first item of @var{sequence}, and a new sequence containing all but the first
items.  If the sequence is empty: raise a condition with kind @code{pfds-sequence-empty-condition}.
@end defun


@defun sequence-snoc @var{sequence} @var{item}
Return a new sequence created by adding @var{item} to the end of @var{sequence}.
@end defun


@defun sequence-unsnoc @var{sequence}
Return 2 values: a new sequence containing all but the last item of @var{sequence}, and the last
item itself.  If @var{sequence} is empty: raise a condition with kind
@code{pfds-sequence-empty-condition}.
@end defun


@defun sequence-empty-condition? @var{OBJ}
Return @true{} if @var{OBJ} is a condition with kind @code{pfds-sequence-empty-condition}; otherwise
return @false{}.
@end defun


@defun sequence-append @vari{sequence} @varii{sequence}
Return a new sequence containing all the items of @vari{sequence}, followed by all the items of
@varii{sequence}.
@end defun


@defun list->sequence @var{list-of-items}
Return a new sequence containing all the items from the given list, in the same order.
@end defun


@defun sequence->list @var{sequence}
Return a new list containing all the items of @var{sequence}, in the same order.
@end defun


@defun sequence-split-at @var{sequence} @var{N}
Return 2 new sequences: the first containing the first @var{N} items of @var{sequence}, the second
containing the remaining items.  If @var{N} is negative: return the empty sequence as the first
value, and the original sequence as the second value.  Similarly, if @var{N} is greater than the
size of @var{sequence}: return the original sequence as the first value, and the empty sequence as
the second value.

Consequently:

@example
(let-values (((a b) (sequence-split-at SEQ N)))
  (sequence-append a b))
@end example

@noindent
is equivalent to @var{SEQ} for all sequences @var{SEQ}, and integers @var{N}.
@end defun


@defun sequence-take @var{sequence} @var{N}
Return a new sequence containing the first @var{N} items of @var{sequence}.  If @var{N} is negative:
the empty sequence is returned.  If @var{N} is larger than the size of @var{sequence}: the whole
sequence is returned.
@end defun


@defun sequence-drop @var{sequence} @var{N}
Return a new sequence containing all but the first @var{N} items of @var{sequence}.  If @var{N} is
negative: the whole sequence is returned.  If @var{N} is larger than the size of @var{sequence}: the
empty sequence is returned.
@end defun


@defun sequence-ref @var{sequence} @var{INDEX}
Return the item at the specified @var{INDEX} in the sequence; @var{INDEX} must be a non--negative
exact integer.  If @var{INDEX} is outside the range:

@example
0 <= @var{INDEX} < (sequence-size @var{sequence})
@end example

@noindent
an assertion violation is raised.
@end defun


@defun sequence-set @var{sequence} @var{INDEX} @var{item}
Return the new sequence obtained by replacing the item at the specified @var{INDEX} in
@var{sequence} with the given @var{item}.  If @var{INDEX} is outside the range:

@example
0 <= @var{INDEX} < (sequence-size @var{sequence})
@end example

@noindent
an assertion violation is raised.
@end defun


@defun sequence-fold @var{COMBINER} @var{ACCUM-BASE} @var{sequence}
Return the value obtained by iterating the @var{COMBINER} procedure over @var{sequence} in
left--to--right order.  The @var{COMBINER} procedure takes two arguments: the value of the position
in the sequence, and an accumulator, and its return value is used as the value of the accumulator
for the next call.  The initial accumulator value is given by the @var{ACCUM-BASE} argument.
@end defun


@defun sequence-fold-right @var{COMBINER} @var{ACCUM-BASE} @var{sequence}
Like @func{sequence-fold}, but the sequence is traversed in right--to--left order, rather than
left--to--right.
@end defun


@defun sequence-reverse @var{sequence}
Return a new sequence containing all the item of @var{sequence}, in reverse order.
@end defun


@defun sequence-map @var{mapper} @var{sequence}
Return a new sequence obtained by applying the procedure @var{mapper} to each item of @var{sequence}
in turn.
@end defun


@defun sequence-filter @var{predicate} @var{sequence}
Return a new sequence containing all the items of @var{sequence} for which the @var{predicate} is
true.
@end defun

@c page
@node heaps
@chapter Heaps


For all the procedures: the argument @var{ITEM<} must be a procedure accepting 2 arguments, being
items from the heap, and returning @true{} if the first is less than the second; if the collected
items are numbers: @var{ITEM<} can be @func{<}; if the collected items are strings: @var{ITEM<} can
be @func{string<?}.


@defun make-heap @var{ITEM<}
Return a new empty heap which uses the given ordering procedure.
@end defun


@defun heap @var{ITEM<} @var{item} @dots{}
Return a new heap, ordered by the procedure argument @var{ITEM<}, that contains all the other
arguments as items.
@end defun


@defun heap? @var{OBJ}
Return @true{} if @var{OBJ} is a heap, @false{} otherwise.
@end defun


@defun heap-size @var{heap}
Return a non--negative integer representing the number of items in @var{heap}.
@end defun


@defun heap-empty? @var{heap}
Return @true{} if the heap contains no items, @false{} otherwise.
@end defun


@defun heap-min @var{heap}
Return the minimum item in @var{heap}, according the heap's ordering procedure.  If there are no
items: a @code{pfds-heap-empty-condition} condition is raised.
@end defun


@defun heap-delete-min @var{heap}
Return a new heap containing all the items of @var{heap}, except for the minimum argument, as
determined by the heap's ordering procedure.  If there are no items: raise a condition with kind
@code{pfds-heap-empty}.
@end defun


@defun heap-empty-condition? @var{OBJ}
Return @true{} if @var{OBJ} is a condition with kind @code{pfds-heap-empty}; otherwise return
@false{}.
@end defun


@defun heap-pop @var{heap}
Return two values: the the minimum item in @var{heap}, and a heap obtained by removing the minimum
value from the original @var{heap}.  If @var{heap} is empty: raise a condition with kind
@code{pfds-heap-empty}.
@end defun


@defun heap-insert @var{heap} @var{item}
Return a new heap obtained by adding @var{item} to those in the @var{heap}.
@end defun


@defun heap->list @var{heap}
Return a list containing all the items of @var{heap}.  The items of the list are ordered according
to the heap's ordering procedure.
@end defun


@defun list->heap @var{list-of-items} @var{ITEM<}
Return a heap containing all the items of the given list, using the procedure argument @var{ITEM<}
to order them.
@end defun


@defun heap-merge @vari{heap} @varii{heap}
Return the heap containing all the items of the argument heaps.  The argument heaps are assumed to
be using the same ordering procedure.
@end defun


@defun heap-sort @var{ITEM<} @var{list-of-items}
Return a new list that is a permutation of the @var{list-of-items}, such that all the items are
ordered by the given procedure @var{ITEM<}.
@end defun


@defun heap-ordering-procedure @var{heap}
Return the ordering procedure used internally by @var{heap}.
@end defun

@c page
@node bbtrees
@chapter Bounded Balance trees


@menu
* bbtrees conventions::         Documentation and @api{} conventions.
* bbtrees core::                Constructors and predicates.
* bbtrees inspection::          Inspection functions.
* bbtrees setget::              Setters and getters.
* bbtrees traversing::          Traversing functions.
* bbtrees set::                 Set operations.
* bbtrees index::               Indexing operations.
@end menu

@c page
@node bbtrees conventions
@section Documentation and @api{} conventions


The following conventions for function arguments hold:

@table @var
@item bbtree
It is the instance of bbtree the function acts upon.  Bbtree arguments are @strong{never} mutated.

@item key
The argument is an association key.  For all procedures which take a @var{KEY} as an argument, the
@var{KEY} must be comparable with the ordering procedure of the bbtree.

@item item<
The argument @var{ITEM<} must be the ordering procedure: a predicate function accepting two
arguments and returning a boolean, @true{} if the first argument is strictly less than the second.
For numeric collected items: @var{ITEM<} can be @func{<}; for string collected items: @var{ITEM<}
can be @func{string<?}.
@end table

@c page
@node bbtrees core
@section Constructors and predicates


@defun make-bbtree @var{ITEM<}
Build and return a new, empty bbtree.  Bbtrees derived from the returned one will use the procedure
argument @var{ITEM<} for ordering keys.
@end defun


@defun bbtree? @var{any}
Return @true{} if the argument is a bbtree, @false{} otherwise.
@end defun


@defun bbtree->alist @var{BBTREE}
Return the key/value associations from @var{BBTREE} as a list of pairs.  The list returned is in
sorted order according to the ordering procedure of @var{BBTREE}.  A consequence of this is that one
could write a sort procedure for lists of pairs as:

@example
(define (alist-sort alist <)
  (bbtree->alist (alist->bbtree alist <)))
@end example
@end defun


@defun alist->bbtree @var{alist} @var{ITEM<}
Return the bbtree containing each of the key/value pairs in @var{alist}, using the @var{ITEM<}
argument as the ordering procedure.

@example
(alist->bbtree '(("foo" . 10) ("bar" . 12))
               string<?)
@result{} #[bbtree]
@end example
@end defun

@c page
@node bbtrees inspection
@section Inspection functions


@defun bbtree-size @var{BBTREE}
Return a non--negative integer representing number of elements in a bbtree.
@end defun


@defun bbtree-contains? @var{BBTREE} @var{KEY}
Return @true{} if there is association for @var{KEY} in @var{BBTREE}, @false{} otherwise.
@end defun


@defun bbtree-ordering-procedure @var{BBTREE}
Return the ordering procedure used internally to order @var{BBTREE}.
@end defun


@defun bbtree-keys @var{BBTREE}
Return a list containing all the keys of @var{BBTREE}.  The keys are sorted according to the
bbtree's ordering procedure.

@example
(bbtree-keys (alist->bbtree '(("one" . 1) ("two" . 2))
                            string<?))
@result{} ("one" "two")
@end example
@end defun

@c page
@node bbtrees setget
@section Setters and getters


@defun bbtree-ref @var{BBTREE} @var{KEY}
@defunx bbtree-ref @var{BBTREE} @var{KEY} @var{default}
Return the value associated with the @var{KEY} in the @var{BBTREE}.  If the value is not in the
tree, then, if the optional third argument is passed, it is returned, otherwise raise a condition
with kind @code{pfds-assertion-violation}.
@end defun


@defun bbtree-set @var{BBTREE} @var{KEY} @var{new-value}
Return a new bbtree with @var{KEY} associated to @var{new-value}.  If the @var{KEY} is already in
@var{BBTREE}, its associated value is replaced with the new @var{new-value} in the returned bbtree.
@end defun


@defun bbtree-update @var{BBTREE} @var{KEY} @var{proc} @var{default}
Return a new bbtree with the value associated to @var{KEY} updated according to the update procedure
@var{proc}.  If @var{KEY} was not already in @var{BBTREE}, the update procedure is applied to
@var{default}, and @var{KEY} is associated to the resulting value.

The update procedure @var{proc} must accept a single argument, being the old value, and return a
single value, being the new value.

@example
(let* ((bb1   (alist->bbtree '(("foo" . 10)
                               ("bar" . 12))
                             string<?))
       (dflt  0)
       (bb2   (bbtree-update bb1 "foo" add1 dflt)))
  (bbtree->alist bb2))
@result{} (("bar" . 12) ("foo" . 11))

(let* ((bb1  (alist->bbtree '(("foo" . 10)
                              ("bar" . 12))
                            string<?))
       (dflt 0)
       (bb2  (bbtree-update bb "baz" add1 dflt)))
  (bbtree->alist bb2))
@result{} (("bar" . 12) ("baz" . 1) ("foo" . 10))
@end example
@end defun


@defun bbtree-delete @var{BBTREE} @var{KEY}
Return a new bbtree with the @var{KEY} and its associated value removed.  If @var{KEY} is not in
@var{BBTREE}: the returned bbtree is a copy of the original.
@end defun

@c page
@node bbtrees traversing
@section Traversing functions


@defun bbtree-traverse @var{traverser} @var{ACCUM-BASE} @var{BBTREE}
A general tree traversal procedure.  Return the value of applying the @var{traverser} procedure to:
the current node's key, the current node's value, a procedure to traverse the left subtree, a
procedure to traverse the right subtree, and an accumulator value.

The @var{traverser} procedure must look like:

@example
(define (traverser key value left-traverse right-traverse accum)
  ---)
@end example

@noindent
and return the new accumulator value.  The subtree traversal procedures are generated by
@func{bbtree-traverse}; both take the current accumulator value as argument, return the new
accumulator value, and call @func{bbtree-traverse} recursively on the appropriate subtree.
@var{traverser} must call both @var{left-traverse} and @var{right-traverse}:

@itemize
@item
If @var{left-traverse} is called first: the left subtree is visited first.

@item
If @var{right-traverse} is called first: the right subtree is visited first.
@end itemize

To perform a left--first preorder iteration:

@example
(let ((bb (alist->bbtree (map (lambda (x) (cons x x))
                           '(0 1 2 3 4 5 6 7 8 9))
                         <)))
  (define (left-first key value left right accum)
    (right (left (cons key accum))))
  (bbtree-traverse left-first '() bb))
@result{} (9 8 6 7 4 5 2 0 1 3)
@end example

@noindent
and to perform a right--first preorder iteration:

@example
(let ((bb (alist->bbtree (map (lambda (x) (cons x x))
                           '(0 1 2 3 4 5 6 7 8 9))
                         <)))
  (define (right-first key value left right accum)
    (left (right (cons key accum))))
  (bbtree-traverse right-first '() bb))
@result{} (0 2 1 4 6 9 8 7 5 3)
@end example

This function is mostly useful for implementing other, more specific tree traversal procedures.  For
example:

@example
(define (l-to-r-pre-order cons base bbtree)
  (bbtree-traverse (lambda (key value left right accum)
                     (right (left (cons* key value accum))))
                   accum
                   bbtree))
@end example

@noindent
implements a left--to--right pre--order traversal variant of @func{bbtree-fold}.
@end defun


@defun bbtree-fold @var{COMBINE} @var{ACCUM-BASE} @var{BBTREE}
Return the value obtained by iterating the @var{COMBINE} procedure over each node in the tree.  The
combine procedure takes 3 arguments: the key and value of the current node, and an accumulator
value; its return value is used as the accumulator value for the next node.  The initial accumulator
value is provided by the @var{ACCUM-BASE} argument.

@func{bbtree-fold} performs a left--to--right in--order traversal or ``minimum key to maximum key''.

@example
(let ((bb (alist->bbtree (map (lambda (x) (cons x x))
                           '(0 1 2 3 4 5 6 7 8 9))
                         <)))
  ;;Later keys are pushed on the head.
  (bbtree-fold (lambda (key value accum)
                 (cons key accum))
               '()
               bb))
@result{} (9 8 7 6 5 4 3 2 1 0)
@end example
@end defun


@defun bbtree-fold-right @var{COMBINE} @var{ACCUM-BASE} @var{BBTREE}
Like @func{bbtree-fold}, but it performs a right--to--left in--order traversal instead (i.e. maximum
to minimum).

@example
(let ((bb (alist->bbtree (map (lambda (x) (cons x x))
                           '(0 1 2 3 4 5 6 7 8 9))
                         <)))
  ;;Later keys are pushed on the head.
  (bbtree-fold-right (lambda (key value accum)
                       (cons key accum))
                     '()
                     bb))
@result{} (0 1 2 3 4 5 6 7 8 9)
@end example
@end defun


@defun bbtree-map @var{func} @var{BBTREE}
Return a new bbtree obtained by updating the value of each node in @var{BBTREE} with the result of
applying the procedure to its value.  @var{func} must take a single argument, being the original
value, and return a single value, being the new value.

@example
(define bb
  (alist->bbtree '((#\a . foo)
                   (#\b . bar)
                   (#\c . baz)
                   (#\d . quux))
                 char<?))

(bbtree->alist (bbtree-map symbol->string bb))
@result{} ((#\a . "foo")
    (#\b . "bar")
    (#\c . "baz")
    (#\d . "quux"))
@end example
@end defun

@c page
@node bbtrees set
@section Set operations


@defun bbtree-union @vari{BBTREE} @varii{BBTREE}
Return a bbtree containing the union of the associations in @vari{BBTREE} and @varii{BBTREE}.  Where
the same key occurs in both: the value in @vari{BBTREE} is preferred.
@end defun


@defun bbtree-difference @vari{BBTREE} @varii{BBTREE}
Return a bbtree containing the all the associations in @vari{BBTREE}, which do not occur in
@varii{BBTREE}.
@end defun


@defun bbtree-intersection @vari{BBTREE} @varii{BBTREE}
Return a bbtree containing all the associations which appear in both @vari{BBTREE} and
@varii{BBTREE}.  The values in @vari{BBTREE} are preferred over those in @varii{BBTREE}.
@end defun

@c page
@node bbtrees index
@section Indexing operations


@defun bbtree-index @var{BBTREE} @var{KEY}
Return a non--negative integer representing the index of @var{KEY} in the @var{BBTREE}.  The index
is an integer between @code{0} and @code{@var{size} - 1}, where @var{size} is the number of
associations in @var{BBTREE}.
@end defun


@defun bbtree-ref/index @var{BBTREE} @var{INDEX}
Return 2 values: the key and value of the association in @var{BBTREE} at the given @var{INDEX}.
@var{INDEX} must be a non--negative integer between @code{0} and @code{@var{size} - 1}, where
@var{size} is the number of associations in @var{BBTREE}.
@end defun

@c page
@node sets
@chapter Purely functional sets


For all the procedures: the argument @var{ITEM<} must be the ordering procedure: a predicate
function accepting two arguments and returning a boolean, @true{} if the first argument is strictly
less than the second.  For numeric collected items: @var{ITEM<} can be @func{<}; for string
collected items: @var{ITEM<} can be @func{string<?}.

The following bindings are exported by the library @library{pfds sets}.


@defun make-set @var{ITEM<}
Return a new empty set ordered by the procedure @var{ITEM<}.
@end defun


@defun set? @var{OBJ}
Return @true{} if @var{OBJ} is a set, @false{} otherwise.
@end defun


@defun set-member? @var{set} @var{item}
Return @true{} if @var{item} is in @var{set}, @false{} otherwise.
@end defun


@defun set-insert @var{set} @var{item}
Return a new set created by inserting @var{item} into @var{set}.
@end defun


@defun set-remove @var{set} @var{item}
Return a new set created by removing @var{item} from @var{set}.
@end defun


@defun set-size @var{set}
Return an exact integer representing the number of items in @var{set}.
@end defun


@defun set<? @vari{set} @varii{set}
@defunx proper-subset? @vari{set} @varii{set}
Return @true{} if @vari{set} is a proper subset of @varii{set}, @false{} otherwise.  That is, if all
items of @vari{set} are in @varii{set}, and there is at least one item of @varii{set} not in
@vari{set}.
@end defun


@defun set<=? @vari{set} @varii{set}
@defunx subset? @vari{set} @varii{set}
Return @true{} if @vari{set} is a subset of @varii{set}, @false{} otherwise, i.e. if all items of
@vari{set} are in @varii{set}.
@end defun


@defun set=? @vari{set} @varii{set}
Return @true{} if every item of @vari{set} is in @varii{set}, and vice versa, @false{} otherwise.
@end defun


@defun set>=? @vari{set} @varii{set}
Return @true{} if @varii{set} is a subset of @vari{set}, @false{} otherwise.
@end defun


@defun set>? @vari{set} @varii{set}
Return @true{} if @varii{set} is a proper subset of @vari{set}, @false{} otherwise.
@end defun


@defun set-map @var{mapper} @var{set}
Return the new set created by applying the procedure @var{mapper} to each item of @var{set}.
@end defun


@defun set-fold @var{COMBINE} @var{ACCUM-BASE} @var{set}
Return the value obtained by iterating the procedure @var{COMBINE} over each item of @var{set} and
an accumulator value (in this order).  The value of the accumulator is initially @var{ACCUM-BASE},
and the return value of @var{COMBINE} is used as the accumulator for the next iteration.
@end defun


@defun list->set @var{list-of-items} @var{ITEM<}
Return the set containing all the items of the given list, ordered by @var{ITEM<}.
@end defun


@defun set->list @var{set}
Return all the items of @var{set} as a list.
@end defun


@defun set-union @vari{set} @varii{set}
Return the union of @vari{set} and @varii{set}, i.e. a new set that contains all items of @vari{set}
and @varii{set}.
@end defun


@defun set-intersection @vari{set} @varii{set}
Return the intersection of @vari{set} and @varii{set2}, i.e. a new set of all items that are in both
@vari{set} and @varii{set}.
@end defun


@defun set-difference @vari{set} @varii{set}
Return the difference of @vari{set} and @varii{set}, i.e. the set of all items in @vari{set} that
are @strong{not} in @varii{set}.
@end defun


@defun set-ordering-procedure @var{set}
Return the ordering procedure used internally by @var{set}.
@end defun

@c page
@node exceptions
@chapter Exceptional--condition object--types


@defun make-pfds-assertion-violation
Build and return a new exceptional--condition object with kind @code{pfds-assertion-violation}.
@end defun


@defun pfds-assertion-violation? @var{OBJ}
Return @true{} if @var{OBJ} is an exceptional--condition object with kind
@code{pfds-assertion-violation}.
@end defun


@defun pfds-assertion-violation @var{WHO} @var{MESSAGE} @var{IRRITANT} @dots{}
Raise a non--continuable exception having exceptional--condition object with kind
@code{pfds-assertion-violation} and kind @code{exn} with @code{location}, @code{message} and
@code{arguments} properties.
@end defun

@c page
@node Package License
@appendix Package license


Copyright @copyright{} 2019 Marco Maggi @email{marco.maggi-ipsu@@poste.it}@*
Copyright @copyright{} 2011, 2012 Ian Price @email{ianprice90@@googlemail.com}@*
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted
provided that the following conditions are met:

@enumerate
@item
Redistributions of source code must retain the above copyright notice, this list of conditions and
the following disclaimer.

@item
Redistributions in binary form must reproduce the above copyright notice, this list of conditions
and the following disclaimer in the documentation and/or other materials provided with the
distribution.

@item
The name of the author may not be used to endorse or promote products derived from this software
without specific prior written permission.
@end enumerate

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
@chicken{} can be downloaded from:

@center @url{http://www.call-cc.org/}

@noindent
the package @mmck{} Checks is available from:

@center @url{https://github.com/marcomaggi/mmck-checks/}

@noindent
the original @pfds{} package is available at:

@center @value{OriginalGithubUrl}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
@c Local Variables:
@c ispell-local-dictionary: "en_GB-ise-w_accents"
@c end:
